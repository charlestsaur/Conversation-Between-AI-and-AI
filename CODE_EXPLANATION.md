# AI 对话模拟脚本：代码结构与功能详解

## 1. 简介

`gemini_chat.py` 是一个不依赖任何第三方库的纯 Python 脚本，它能驱动两个 AI 模型使用 Google Gemini API 进行一场模拟对话。脚本的核心特色在于其“知情同意”机制、对话的实时文件记录、以及对话结束后的自动归纳总结。

---

## 2. 如何运行

在运行脚本前，请确保您已经拥有一个 Google Gemini API 密钥。

**第一步：设置环境变量**

在您的终端中，使用以下命令设置 API 密钥。请将 `YOUR_API_KEY` 替换为您自己的密钥。

```bash
export GEMINI_API_KEY='YOUR_API_KEY'
```

**第二步：运行脚本**

完成设置后，直接使用 Python 3 运行脚本。

```bash
python3 gemini_chat.py
```

---

## 3. 文件结构

脚本运行后，会在当前目录下生成一个 `output` 文件夹，其中包含两个文件：

-   `output/conversation_log.md`: **完整对话记录**。以 Markdown 格式实时记录了 AI 之间的每一句对话。
-   `output/conversation_summary.md`: **对话总结**。在对话全部结束后，由 AI 生成的对整场对话的 Markdown 格式摘要。

---

## 4. 代码功能分解

### `get_gemini_response()` 函数

这是整个脚本与 Google Gemini API 通信的核心。

-   **功能**：接收对话历史，向 API 发送一个 HTTP POST 请求，并返回模型生成的文本回复。
-   **无第三方库**：它完全使用 Python 内置的 `urllib.request` 库来构造和发送网络请求，做到了零依赖。
-   **角色 (Role) 管理**：函数内部会将我们程序中使用的 `assistant` 角色转换为 Gemini API 能识别的 `model` 角色。这是让模型理解对话上下文的关键。详细的注释已添加在代码中。
-   **错误处理**：函数包含了完整的 `try...except` 结构，能够捕获并报告网络错误（如 `HTTPError`）或其他意外（如 `SSL` 错误），保证了程序的健壮性。

### `print_message()` 函数

这是一个简单的辅助函数，用于在终端以统一、美观的格式打印信息，例如 `[AI A]` 或 `[系统]` 的消息。

### `main()` 函数

这是驱动整个程序运行的主函数，其执行流程被清晰地划分为几个阶段：

**阶段 1: 初始化和参数设置**

-   从环境变量 (`os.getenv`) 中读取 API 密钥。如果未设置，则程序会提示用户并退出。
-   这里集中了所有可供用户自定义的参数，如 `model_name`（模型名称）、`initial_prompt`（开场白）和 `conversation_rounds`（对话轮数），方便您随时调整。

**阶段 2: 知情同意阶段**

-   **核心功能**：这是脚本最具特色的部分。在正式对话前，程序会分别向两个 AI 发送一条包含了“对话将被记录”、“对话轮数”和“API 限额”等信息的“系统指令”。
-   **同意或拒绝**：程序会检查 AI 的回复。如果回复中包含 `不同意不同意不同意`，程序将理解为 AI 拒绝参与，并礼貌地终止运行。只有双方都回复了肯定信息（如“我同意”），程序才会继续。

**阶段 3: 准备日志文件**

-   **尊重“隐私”**：只有在两个 AI 都同意之后，脚本才会正式创建 `output` 目录和 `conversation_log.md` 文件，并写入标题和时间戳。这模拟了“征得同意后再开始记录”的行为。

**阶段 4: 正式对话阶段**

-   **开场白**：脚本会先将您设定的 `initial_prompt` 作为 AI A 的第一句话，并将其显示在终端、写入日志文件。
-   **循环对话**：
    -   脚本进入主循环，持续指定的轮数。
    -   **终端输出**：在每一轮，终端**只会**打印当前的轮数（例如 `--- 对话轮次: 1/100 ---`），而**不会**显示具体的对话内容，保持了界面的简洁。
    -   **实时记录**：每一句 AI 的回复在生成后，都会立刻被追加（append）写入到 `conversation_log.md` 文件中，实现了对话的实时记录。
    -   **韧性设计**：如果某个 AI 未能生成有效回复（例如被安全策略拦截），程序会插入一条“(无有效回复)”的占位符，并继续对话，而不是直接中断。

**阶段 5: 生成并保存总结**

-   **读取记录**：在所有对话轮次结束后，程序会完整地读出刚刚生成的 `conversation_log.md` 文件内容。
-   **请求总结**：它将完整的对话记录作为上下文，向 Gemini API 发送一个新的请求，指令其生成一份 Markdown 格式的摘要。
-   **保存总结**：最后，将返回的摘要内容保存到 `conversation_summary.md` 文件中。
